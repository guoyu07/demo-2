<h1 id="sigmund">sigmund</h1>
<p>Quick and dirty signatures for Objects.</p>
<p>This is like a much faster <code>deepEquals</code> comparison, which returns a<br>string key suitable for caches and the like.</p>
<h2 id="Usage">Usage</h2>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span> <span class="params">(someObj)</span> {</span>
  <span class="keyword">var</span> key = sigmund(someObj, maxDepth) <span class="comment">// max depth defaults to 10</span>
  <span class="keyword">var</span> cached = cache.get(key)
  <span class="keyword">if</span> (cached) <span class="keyword">return</span> cached

  <span class="keyword">var</span> result = expensiveCalculation(someObj)
  cache.set(key, result)
  <span class="keyword">return</span> result
}
</code></pre>
<p>The resulting key will be as unique and reproducible as calling<br><code>JSON.stringify</code> or <code>util.inspect</code> on the object, but is much faster.<br>In order to achieve this speed, some differences are glossed over.<br>For example, the object <code>{0:&#39;foo&#39;}</code> will be treated identically to the<br>array <code>[&#39;foo&#39;]</code>.</p>
<p>Also, just as there is no way to summon the soul from the scribblings<br>of a cocaine-addled psychoanalyst, there is no way to revive the object<br>from the signature string that sigmund gives you.  In fact, it’s<br>barely even readable.</p>
<p>As with <code>util.inspect</code> and <code>JSON.stringify</code>, larger objects will<br>produce larger signature strings.</p>
<p>Because sigmund is a bit less strict than the more thorough<br>alternatives, the strings will be shorter, and also there is a<br>slightly higher chance for collisions.  For example, these objects<br>have the same signature:</p>
<pre><code>var obj1 = {a:<span class="string">'b'</span>,c:/<span class="function"><span class="keyword">def</span>/,<span class="title">g</span>:</span>[<span class="string">'h'</span>,<span class="string">'i'</span>,{j:<span class="string">''</span>,k:<span class="string">'l'</span>}]}
var obj2 = {a:<span class="string">'b'</span>,c:<span class="string">'/def/'</span>,g:[<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'{jkl'</span>]}
</code></pre><p>Like a good Freudian, sigmund is most effective when you already have<br>some understanding of what you’re looking for.  It can help you help<br>yourself, but you must be willing to do some work as well.</p>
<p>Cycles are handled, and cyclical objects are silently omitted (though<br>the key is included in the signature output.)</p>
<p>The second argument is the maximum depth, which defaults to 10,<br>because that is the maximum object traversal depth covered by most<br>insurance carriers.</p>
