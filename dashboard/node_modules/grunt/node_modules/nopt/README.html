<p>If you want to write an option parser, and have it be good, there are<br>two ways to do it.  The Right Way, and the Wrong Way.</p>
<p>The Wrong Way is to sit down and write an option parser.  We’ve all done<br>that.</p>
<p>The Right Way is to write some complex configurable program with so many<br>options that you go half-insane just trying to manage them all, and put<br>it off with duct-tape solutions until you see exactly to the core of the<br>problem, and finally snap and write an awesome option parser.</p>
<p>If you want to write an option parser, don’t write an option parser.<br>Write a package manager, or a source control system, or a service<br>restarter, or an operating system.  You probably won’t end up with a<br>good one of those, but if you don’t give up, and you are relentless and<br>diligent enough in your procrastination, you may just end up with a very<br>nice option parser.</p>
<h2 id="USAGE">USAGE</h2>
<pre><code><span class="comment">// my-program.js</span>
<span class="keyword">var</span> nopt = <span class="built_in">require</span>(<span class="string">"nopt"</span>)
  , Stream = <span class="built_in">require</span>(<span class="string">"stream"</span>).Stream
  , path = <span class="built_in">require</span>(<span class="string">"path"</span>)
  , knownOpts = { <span class="string">"foo"</span> : [<span class="built_in">String</span>, <span class="literal">null</span>]
                , <span class="string">"bar"</span> : [Stream, <span class="built_in">Number</span>]
                , <span class="string">"baz"</span> : path
                , <span class="string">"bloo"</span> : [ <span class="string">"big"</span>, <span class="string">"medium"</span>, <span class="string">"small"</span> ]
                , <span class="string">"flag"</span> : <span class="built_in">Boolean</span>
                , <span class="string">"pick"</span> : <span class="built_in">Boolean</span>
                , <span class="string">"many"</span> : [<span class="built_in">String</span>, <span class="built_in">Array</span>]
                }
  , shortHands = { <span class="string">"foofoo"</span> : [<span class="string">"--foo"</span>, <span class="string">"Mr. Foo"</span>]
                 , <span class="string">"b7"</span> : [<span class="string">"--bar"</span>, <span class="string">"7"</span>]
                 , <span class="string">"m"</span> : [<span class="string">"--bloo"</span>, <span class="string">"medium"</span>]
                 , <span class="string">"p"</span> : [<span class="string">"--pick"</span>]
                 , <span class="string">"f"</span> : [<span class="string">"--flag"</span>]
                 }
             <span class="comment">// everything is optional.</span>
             <span class="comment">// knownOpts and shorthands default to {}</span>
             <span class="comment">// arg list defaults to process.argv</span>
             <span class="comment">// slice defaults to 2</span>
  , parsed = nopt(knownOpts, shortHands, process.argv, <span class="number">2</span>)
console.log(parsed)
</code></pre><p>This would give you support for any of the following:</p>
<pre><code class="bash">$ node my-program.js --foo <span class="string">"blerp"</span> --no-flag
{ <span class="string">"foo"</span> : <span class="string">"blerp"</span>, <span class="string">"flag"</span> : <span class="literal">false</span> }

$ node my-program.js ---bar <span class="number">7</span> --foo <span class="string">"Mr. Hand"</span> --flag
{ bar: <span class="number">7</span>, foo: <span class="string">"Mr. Hand"</span>, flag: <span class="literal">true</span> }

$ node my-program.js --foo <span class="string">"blerp"</span> <span class="operator">-f</span> -----p
{ foo: <span class="string">"blerp"</span>, flag: <span class="literal">true</span>, pick: <span class="literal">true</span> }

$ node my-program.js -fp --foofoo
{ foo: <span class="string">"Mr. Foo"</span>, flag: <span class="literal">true</span>, pick: <span class="literal">true</span> }

$ node my-program.js --foofoo -- -fp  <span class="comment"># -- stops the flag parsing.</span>
{ foo: <span class="string">"Mr. Foo"</span>, argv: { remain: [<span class="string">"-fp"</span>] } }

$ node my-program.js --blatzk <span class="number">1000</span> -fp <span class="comment"># unknown opts are ok.</span>
{ blatzk: <span class="number">1000</span>, flag: <span class="literal">true</span>, pick: <span class="literal">true</span> }

$ node my-program.js --blatzk <span class="literal">true</span> -fp <span class="comment"># but they need a value</span>
{ blatzk: <span class="literal">true</span>, flag: <span class="literal">true</span>, pick: <span class="literal">true</span> }

$ node my-program.js --no-blatzk -fp <span class="comment"># unless they start with "no-"</span>
{ blatzk: <span class="literal">false</span>, flag: <span class="literal">true</span>, pick: <span class="literal">true</span> }

$ node my-program.js --baz b/a/z <span class="comment"># known paths are resolved.</span>
{ baz: <span class="string">"/Users/isaacs/b/a/z"</span> }

<span class="comment"># if Array is one of the types, then it can take many</span>
<span class="comment"># values, and will always be an array.  The other types provided</span>
<span class="comment"># specify what types are allowed in the list.</span>

$ node my-program.js --many <span class="number">1</span> --many null --many foo
{ many: [<span class="string">"1"</span>, <span class="string">"null"</span>, <span class="string">"foo"</span>] }

$ node my-program.js --many foo
{ many: [<span class="string">"foo"</span>] }
</code></pre>
<p>Read the tests at the bottom of <code>lib/nopt.js</code> for more examples of<br>what this puppy can do.</p>
<h2 id="Types">Types</h2>
<p>The following types are supported, and defined on <code>nopt.typeDefs</code></p>
<ul>
<li>String: A normal string.  No parsing is done.</li>
<li>path: A file system path.  Gets resolved against cwd if not absolute.</li>
<li>url: A url.  If it doesn’t parse, it isn’t accepted.</li>
<li>Number: Must be numeric.</li>
<li>Date: Must parse as a date. If it does, and <code>Date</code> is one of the options,<br>then it will return a Date object, not a string.</li>
<li>Boolean: Must be either <code>true</code> or <code>false</code>.  If an option is a boolean,<br>then it does not need a value, and its presence will imply <code>true</code> as<br>the value.  To negate boolean flags, do <code>--no-whatever</code> or <code>--whatever
false</code></li>
<li>NaN: Means that the option is strictly not allowed.  Any value will<br>fail.</li>
<li>Stream: An object matching the “Stream” class in node.  Valuable<br>for use when validating programmatically.  (npm uses this to let you<br>supply any WriteStream on the <code>outfd</code> and <code>logfd</code> config options.)</li>
<li>Array: If <code>Array</code> is specified as one of the types, then the value<br>will be parsed as a list of options.  This means that multiple values<br>can be specified, and that the value will always be an array.</li>
</ul>
<p>If a type is an array of values not on this list, then those are<br>considered valid values.  For instance, in the example above, the<br><code>--bloo</code> option can only be one of <code>&quot;big&quot;</code>, <code>&quot;medium&quot;</code>, or <code>&quot;small&quot;</code>,<br>and any other value will be rejected.</p>
<p>When parsing unknown fields, <code>&quot;true&quot;</code>, <code>&quot;false&quot;</code>, and <code>&quot;null&quot;</code> will be<br>interpreted as their JavaScript equivalents, and numeric values will be<br>interpreted as a number.</p>
<p>You can also mix types and values, or multiple types, in a list.  For<br>instance <code>{ blah: [Number, null] }</code> would allow a value to be set to<br>either a Number or null.</p>
<p>To define a new type, add it to <code>nopt.typeDefs</code>.  Each item in that<br>hash is an object with a <code>type</code> member and a <code>validate</code> method.  The<br><code>type</code> member is an object that matches what goes in the type list.  The<br><code>validate</code> method is a function that gets called with <code>validate(data,
key, val)</code>.  Validate methods should assign <code>data[key]</code> to the valid<br>value of <code>val</code> if it can be handled properly, or return boolean<br><code>false</code> if it cannot.</p>
<p>You can also call <code>nopt.clean(data, types, typeDefs)</code> to clean up a<br>config object and remove its invalid properties.</p>
<h2 id="Error_Handling">Error Handling</h2>
<p>By default, nopt outputs a warning to standard error when invalid<br>options are found.  You can change this behavior by assigning a method<br>to <code>nopt.invalidHandler</code>.  This method will be called with<br>the offending <code>nopt.invalidHandler(key, val, types)</code>.</p>
<p>If no <code>nopt.invalidHandler</code> is assigned, then it will console.error<br>its whining.  If it is assigned to boolean <code>false</code> then the warning is<br>suppressed.</p>
<h2 id="Abbreviations">Abbreviations</h2>
<p>Yes, they are supported.  If you define options like this:</p>
<pre><code class="javascript">{ <span class="string">"foolhardyelephants"</span> : <span class="built_in">Boolean</span>
, <span class="string">"pileofmonkeys"</span> : <span class="built_in">Boolean</span> }
</code></pre>
<p>Then this will work:</p>
<pre><code class="bash">node program.js --foolhar --pil
node program.js --no<span class="operator">-f</span> --pileofmon
<span class="comment"># etc.</span>
</code></pre>
<h2 id="Shorthands">Shorthands</h2>
<p>Shorthands are a hash of shorter option names to a snippet of args that<br>they expand to.</p>
<p>If multiple one-character shorthands are all combined, and the<br>combination does not unambiguously match any other option or shorthand,<br>then they will be broken up into their constituent parts.  For example:</p>
<pre><code class="json">{ "<span class="attribute">s</span>" : <span class="value">[<span class="string">"--loglevel"</span>, <span class="string">"silent"</span>]
</span>, "<span class="attribute">g</span>" : <span class="value"><span class="string">"--global"</span>
</span>, "<span class="attribute">f</span>" : <span class="value"><span class="string">"--force"</span>
</span>, "<span class="attribute">p</span>" : <span class="value"><span class="string">"--parseable"</span>
</span>, "<span class="attribute">l</span>" : <span class="value"><span class="string">"--long"</span>
</span>}
</code></pre>
<pre><code class="bash">npm ls -sgflp
<span class="comment"># just like doing this:</span>
npm ls --loglevel silent --global --force --long --parseable
</code></pre>
<h2 id="The_Rest_of_the_args">The Rest of the args</h2>
<p>The config object returned by nopt is given a special member called<br><code>argv</code>, which is an object with the following fields:</p>
<ul>
<li><code>remain</code>: The remaining args after all the parsing has occurred.</li>
<li><code>original</code>: The args as they originally appeared.</li>
<li><code>cooked</code>: The args after flags and shorthands are expanded.</li>
</ul>
<h2 id="Slicing">Slicing</h2>
<p>Node programs are called with more or less the exact argv as it appears<br>in C land, after the v8 and node-specific options have been plucked off.<br>As such, <code>argv[0]</code> is always <code>node</code> and <code>argv[1]</code> is always the<br>JavaScript program being run.</p>
<p>That’s usually not very useful to you.  So they’re sliced off by<br>default.  If you want them, then you can pass in <code>0</code> as the last<br>argument, or any other number that you’d like to slice off the start of<br>the list.</p>
