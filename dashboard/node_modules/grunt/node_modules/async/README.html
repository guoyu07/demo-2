<h1 id="Async-js">Async.js</h1>
<p>Async is a utility module which provides straight-forward, powerful functions<br>for working with asynchronous JavaScript. Although originally designed for<br>use with <a href="http://nodejs.org">node.js</a>, it can also be used directly in the<br>browser.</p>
<p>Async provides around 20 functions that include the usual ‘functional’<br>suspects (map, reduce, filter, forEach…) as well as some common patterns<br>for asynchronous control flow (parallel, series, waterfall…). All these<br>functions assume you follow the node.js convention of providing a single<br>callback as the last argument of your async function.</p>
<h2 id="Quick_Examples">Quick Examples</h2>
<pre><code>async.map([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.stat, <span class="keyword">function</span>(err, results){
    // results is now an array of stats <span class="keyword">for</span> each file
});

async.filter([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], path.exists, <span class="keyword">function</span>(results){
    // results now equals an array of the existing files
});

async.parallel([
    <span class="keyword">function</span>(){ <span class="keyword">...</span> },
    <span class="keyword">function</span>(){ <span class="keyword">...</span> }
], callback);

async.series([
    <span class="keyword">function</span>(){ <span class="keyword">...</span> },
    <span class="keyword">function</span>(){ <span class="keyword">...</span> }
]);
</code></pre><p>There are many more functions available so take a look at the docs below for a<br>full list. This module aims to be comprehensive, so if you feel anything is<br>missing please create a GitHub issue for it.</p>
<h2 id="Download">Download</h2>
<p>Releases are available for download from<br><a href="http://github.com/caolan/async/downloads">GitHub</a>.<br>Alternatively, you can install using Node Package Manager (npm):</p>
<pre><code>npm install <span class="keyword">async</span>
</code></pre><p><strong>Development:</strong> <a href="https://github.com/caolan/async/raw/master/lib/async.js">async.js</a> - 17.5kb Uncompressed</p>
<p><strong>Production:</strong> <a href="https://github.com/caolan/async/raw/master/dist/async.min.js">async.min.js</a> - 1.7kb Packed and Gzipped</p>
<h2 id="In_the_Browser">In the Browser</h2>
<p>So far its been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. Usage:</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"async.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">

    async.map(data, asyncProcess, <span class="function"><span class="keyword">function</span><span class="params">(err, results)</span>{</span>
        alert(results);
    });

</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><h2 id="Documentation">Documentation</h2>
<h3 id="Collections">Collections</h3>
<ul>
<li><a href="#forEach">forEach</a></li>
<li><a href="#map">map</a></li>
<li><a href="#filter">filter</a></li>
<li><a href="#reject">reject</a></li>
<li><a href="#reduce">reduce</a></li>
<li><a href="#detect">detect</a></li>
<li><a href="#sortBy">sortBy</a></li>
<li><a href="#some">some</a></li>
<li><a href="#every">every</a></li>
<li><a href="#concat">concat</a></li>
</ul>
<h3 id="Control_Flow">Control Flow</h3>
<ul>
<li><a href="#series">series</a></li>
<li><a href="#parallel">parallel</a></li>
<li><a href="#whilst">whilst</a></li>
<li><a href="#until">until</a></li>
<li><a href="#waterfall">waterfall</a></li>
<li><a href="#queue">queue</a></li>
<li><a href="#auto">auto</a></li>
<li><a href="#iterator">iterator</a></li>
<li><a href="#apply">apply</a></li>
<li><a href="#nextTick">nextTick</a></li>
</ul>
<h3 id="Utils">Utils</h3>
<ul>
<li><a href="#memoize">memoize</a></li>
<li><a href="#unmemoize">unmemoize</a></li>
<li><a href="#log">log</a></li>
<li><a href="#dir">dir</a></li>
<li><a href="#noConflict">noConflict</a></li>
</ul>
<h2 id="Collections-1">Collections</h2>
<p><a name="forEach" /></p>
<h3 id="forEach(arr,_iterator,_callback)">forEach(arr, iterator, callback)</h3>
<p>Applies an iterator function to each item in an array, in parallel.<br>The iterator is called with an item from the list and a callback for when it<br>has finished. If the iterator passes an error to this callback, the main<br>callback for the forEach function is immediately called with the error.</p>
<p>Note, that since this function applies the iterator to each item in parallel<br>there is no guarantee that the iterator functions will complete in order.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>iterator(item, callback) - A function to apply to each item in the array.<br>The iterator is passed a callback which must be called once it has completed.</li>
<li>callback(err) - A callback which is called after all the iterator functions<br>have finished, or an error has occurred.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code><span class="regexp">//</span> assuming openFiles <span class="keyword">is</span> an array <span class="keyword">of</span> file names <span class="keyword">and</span> saveFile <span class="keyword">is</span> a <span class="reserved">function</span>
<span class="regexp">//</span> to save the modified contents <span class="keyword">of</span> that <span class="attribute">file</span>:

async.forEach(openFiles, saveFile, <span class="reserved">function</span>(err){
    <span class="regexp">//</span> <span class="keyword">if</span> any <span class="keyword">of</span> the saves produced an error, err would equal that error
});
</code></pre><hr>
<p><a name="forEachSeries" /></p>
<h3 id="forEachSeries(arr,_iterator,_callback)">forEachSeries(arr, iterator, callback)</h3>
<p>The same as forEach only the iterator is applied to each item in the array in<br>series. The next iterator is only called once the current one has completed<br>processing. This means the iterator functions will complete in order.</p>
<hr>
<p><a name="forEachLimit" /></p>
<h3 id="forEachLimit(arr,_limit,_iterator,_callback)">forEachLimit(arr, limit, iterator, callback)</h3>
<p>The same as forEach only the iterator is applied to batches of items in the<br>array, in series. The next batch of iterators is only called once the current<br>one has completed processing.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>limit - How many items should be in each batch.</li>
<li>iterator(item, callback) - A function to apply to each item in the array.<br>The iterator is passed a callback which must be called once it has completed.</li>
<li>callback(err) - A callback which is called after all the iterator functions<br>have finished, or an error has occurred.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code><span class="regexp">//</span> Assume documents <span class="keyword">is</span> an array <span class="keyword">of</span> JSON objects <span class="keyword">and</span> requestApi <span class="keyword">is</span> a
<span class="regexp">//</span> <span class="reserved">function</span> that interacts <span class="reserved">with</span> a rate-limited REST api.

async.forEachLimit(documents, <span class="number">20</span>, requestApi, <span class="reserved">function</span>(err){
    <span class="regexp">//</span> <span class="keyword">if</span> any <span class="keyword">of</span> the saves produced an error, err would equal that error
});
</code></pre><hr>
<p><a name="map" /></p>
<h3 id="map(arr,_iterator,_callback)">map(arr, iterator, callback)</h3>
<p>Produces a new array of values by mapping each value in the given array through<br>the iterator function. The iterator is called with an item from the array and a<br>callback for when it has finished processing. The callback takes 2 arguments,<br>an error and the transformed item from the array. If the iterator passes an<br>error to this callback, the main callback for the map function is immediately<br>called with the error.</p>
<p>Note, that since this function applies the iterator to each item in parallel<br>there is no guarantee that the iterator functions will complete in order, however<br>the results array will be in the same order as the original array.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>iterator(item, callback) - A function to apply to each item in the array.<br>The iterator is passed a callback which must be called once it has completed<br>with an error (which can be null) and a transformed item.</li>
<li>callback(err, results) - A callback which is called after all the iterator<br>functions have finished, or an error has occurred. Results is an array of the<br>transformed items from the original array.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code>async.map([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.stat, <span class="function"><span class="keyword">function</span><span class="params">(err, results)</span>{</span>
    <span class="comment">// results is now an array of stats for each file</span>
});
</code></pre><hr>
<p><a name="mapSeries" /></p>
<h3 id="mapSeries(arr,_iterator,_callback)">mapSeries(arr, iterator, callback)</h3>
<p>The same as map only the iterator is applied to each item in the array in<br>series. The next iterator is only called once the current one has completed<br>processing. The results array will be in the same order as the original.</p>
<hr>
<p><a name="filter" /></p>
<h3 id="filter(arr,_iterator,_callback)">filter(arr, iterator, callback)</h3>
<p><strong>Alias:</strong> select</p>
<p>Returns a new array of all the values which pass an async truth test.<br><em>The callback for each iterator call only accepts a single argument of true or<br>false, it does not accept an error argument first!</em> This is in-line with the<br>way node libraries work with truth tests like path.exists. This operation is<br>performed in parallel, but the results array will be in the same order as the<br>original.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>iterator(item, callback) - A truth test to apply to each item in the array.<br>The iterator is passed a callback which must be called once it has completed.</li>
<li>callback(results) - A callback which is called after all the iterator<br>functions have finished.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code><span class="transposed_variable">async.</span>filter(<span class="matrix">[<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>]</span>, <span class="transposed_variable">path.</span><span class="built_in">exists</span>, <span class="function"><span class="keyword">function</span><span class="params">(results)</span>{</span>
    <span class="comment">// results now equals an array of the existing files</span>
});
</code></pre><hr>
<p><a name="filterSeries" /></p>
<h3 id="filterSeries(arr,_iterator,_callback)">filterSeries(arr, iterator, callback)</h3>
<p><strong>alias:</strong> selectSeries</p>
<p>The same as filter only the iterator is applied to each item in the array in<br>series. The next iterator is only called once the current one has completed<br>processing. The results array will be in the same order as the original.</p>
<hr>
<p><a name="reject" /></p>
<h3 id="reject(arr,_iterator,_callback)">reject(arr, iterator, callback)</h3>
<p>The opposite of filter. Removes values that pass an async truth test.</p>
<hr>
<p><a name="rejectSeries" /></p>
<h3 id="rejectSeries(arr,_iterator,_callback)">rejectSeries(arr, iterator, callback)</h3>
<p>The same as filter, only the iterator is applied to each item in the array<br>in series.</p>
<hr>
<p><a name="reduce" /></p>
<h3 id="reduce(arr,_memo,_iterator,_callback)">reduce(arr, memo, iterator, callback)</h3>
<p><strong>aliases:</strong> inject, foldl</p>
<p>Reduces a list of values into a single value using an async iterator to return<br>each successive step. Memo is the initial state of the reduction. This<br>function only operates in series. For performance reasons, it may make sense to<br>split a call to this function into a parallel map, then use the normal<br>Array.prototype.reduce on the results. This function is for situations where<br>each step in the reduction needs to be async, if you can get the data before<br>reducing it then its probably a good idea to do so.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>memo - The initial state of the reduction.</li>
<li>iterator(memo, item, callback) - A function applied to each item in the<br>array to produce the next step in the reduction. The iterator is passed a<br>callback which accepts an optional error as its first argument, and the state<br>of the reduction as the second. If an error is passed to the callback, the<br>reduction is stopped and the main callback is immediately called with the<br>error.</li>
<li>callback(err, result) - A callback which is called after all the iterator<br>functions have finished. Result is the reduced value.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code>async.reduce([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="number">0</span>, <span class="function"><span class="keyword">function</span><span class="params">(memo, item, callback)</span>{</span>
    <span class="comment">// pointless async:</span>
    process.nextTick(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        callback(<span class="literal">null</span>, memo + item)
    });
}, <span class="function"><span class="keyword">function</span><span class="params">(err, result)</span>{</span>
    <span class="comment">// result is now equal to the last value of memo, which is 6</span>
});
</code></pre><hr>
<p><a name="reduceRight" /></p>
<h3 id="reduceRight(arr,_memo,_iterator,_callback)">reduceRight(arr, memo, iterator, callback)</h3>
<p><strong>Alias:</strong> foldr</p>
<p>Same as reduce, only operates on the items in the array in reverse order.</p>
<hr>
<p><a name="detect" /></p>
<h3 id="detect(arr,_iterator,_callback)">detect(arr, iterator, callback)</h3>
<p>Returns the first value in a list that passes an async truth test. The<br>iterator is applied in parallel, meaning the first iterator to return true will<br>fire the detect callback with that result. That means the result might not be<br>the first item in the original array (in terms of order) that passes the test.</p>
<p>If order within the original array is important then look at detectSeries.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>iterator(item, callback) - A truth test to apply to each item in the array.<br>The iterator is passed a callback which must be called once it has completed.</li>
<li>callback(result) - A callback which is called as soon as any iterator returns<br>true, or after all the iterator functions have finished. Result will be<br>the first item in the array that passes the truth test (iterator) or the<br>value undefined if none passed.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code><span class="keyword">async</span>.detect([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], path.exists, <span class="function"><span class="keyword">function</span><span class="params">(<span class="keyword">result</span>)</span><span class="comment">{
    // result now equals the first file in the list that exists
}</span>);</span>
</code></pre><hr>
<p><a name="detectSeries" /></p>
<h3 id="detectSeries(arr,_iterator,_callback)">detectSeries(arr, iterator, callback)</h3>
<p>The same as detect, only the iterator is applied to each item in the array<br>in series. This means the result is always the first in the original array (in<br>terms of array order) that passes the truth test.</p>
<hr>
<p><a name="sortBy" /></p>
<h3 id="sortBy(arr,_iterator,_callback)">sortBy(arr, iterator, callback)</h3>
<p>Sorts a list by the results of running each value through an async iterator.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>iterator(item, callback) - A function to apply to each item in the array.<br>The iterator is passed a callback which must be called once it has completed<br>with an error (which can be null) and a value to use as the sort criteria.</li>
<li>callback(err, results) - A callback which is called after all the iterator<br>functions have finished, or an error has occurred. Results is the items from<br>the original array sorted by the values returned by the iterator calls.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code>async.sortBy([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], <span class="function"><span class="keyword">function</span><span class="params">(file, callback)</span>{</span>
    fs.stat(file, <span class="function"><span class="keyword">function</span><span class="params">(err, stats)</span>{</span>
        callback(err, stats.mtime);
    });
}, <span class="function"><span class="keyword">function</span><span class="params">(err, results)</span>{</span>
    <span class="comment">// results is now the original array of files sorted by</span>
    <span class="comment">// modified date</span>
});
</code></pre><hr>
<p><a name="some" /></p>
<h3 id="some(arr,_iterator,_callback)">some(arr, iterator, callback)</h3>
<p><strong>Alias:</strong> any</p>
<p>Returns true if at least one element in the array satisfies an async test.<br><em>The callback for each iterator call only accepts a single argument of true or<br>false, it does not accept an error argument first!</em> This is in-line with the<br>way node libraries work with truth tests like path.exists. Once any iterator<br>call returns true, the main callback is immediately called.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>iterator(item, callback) - A truth test to apply to each item in the array.<br>The iterator is passed a callback which must be called once it has completed.</li>
<li>callback(result) - A callback which is called as soon as any iterator returns<br>true, or after all the iterator functions have finished. Result will be<br>either true or false depending on the values of the async tests.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code>async.some([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], path.exists, <span class="function"><span class="keyword">function</span><span class="params">(result)</span></span>{
    // <span class="keyword">if</span> result is <span class="keyword">true</span> <span class="keyword">then</span> at least one of the files exists
});
</code></pre><hr>
<p><a name="every" /></p>
<h3 id="every(arr,_iterator,_callback)">every(arr, iterator, callback)</h3>
<p><strong>Alias:</strong> all</p>
<p>Returns true if every element in the array satisfies an async test.<br><em>The callback for each iterator call only accepts a single argument of true or<br>false, it does not accept an error argument first!</em> This is in-line with the<br>way node libraries work with truth tests like path.exists.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>iterator(item, callback) - A truth test to apply to each item in the array.<br>The iterator is passed a callback which must be called once it has completed.</li>
<li>callback(result) - A callback which is called after all the iterator<br>functions have finished. Result will be either true or false depending on<br>the values of the async tests.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code>async.every([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], path.exists, <span class="function"><span class="keyword">function</span><span class="params">(result)</span></span>{
    // <span class="keyword">if</span> result is <span class="keyword">true</span> <span class="keyword">then</span> every file exists
});
</code></pre><hr>
<p><a name="concat" /></p>
<h3 id="concat(arr,_iterator,_callback)">concat(arr, iterator, callback)</h3>
<p>Applies an iterator to each item in a list, concatenating the results. Returns the<br>concatenated list. The iterators are called in parallel, and the results are<br>concatenated as they return. There is no guarantee that the results array will<br>be returned in the original order of the arguments passed to the iterator function.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over</li>
<li>iterator(item, callback) - A function to apply to each item in the array.<br>The iterator is passed a callback which must be called once it has completed<br>with an error (which can be null) and an array of results.</li>
<li>callback(err, results) - A callback which is called after all the iterator<br>functions have finished, or an error has occurred. Results is an array containing<br>the concatenated results of the iterator function.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code><span class="keyword">async</span>.<span class="keyword">concat</span>([<span class="string">'dir1'</span>,<span class="string">'dir2'</span>,<span class="string">'dir3'</span>], fs.readdir, <span class="function"><span class="keyword">function</span><span class="params">(err, files)</span><span class="comment">{
    // files is now a list of filenames that exist in the 3 directories
}</span>);</span>
</code></pre><hr>
<p><a name="concatSeries" /></p>
<h3 id="concatSeries(arr,_iterator,_callback)">concatSeries(arr, iterator, callback)</h3>
<p>Same as async.concat, but executes in series instead of parallel.</p>
<h2 id="Control_Flow-1">Control Flow</h2>
<p><a name="series" /></p>
<h3 id="series(tasks,_[callback])">series(tasks, [callback])</h3>
<p>Run an array of functions in series, each one running once the previous<br>function has completed. If any functions in the series pass an error to its<br>callback, no more functions are run and the callback for the series is<br>immediately called with the value of the error. Once the tasks have completed,<br>the results are passed to the final callback as an array.</p>
<p>It is also possible to use an object instead of an array. Each property will be<br>run as a function and the results will be passed to the final callback as an object<br>instead of an array. This can be a more readable way of handling results from<br>async.series.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>tasks - An array or object containing functions to run, each function is passed<br>a callback it must call on completion.</li>
<li>callback(err, results) - An optional callback to run once all the functions<br>have completed. This function gets an array of all the arguments passed to<br>the callbacks used in the array.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code>async.series([
    <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        <span class="comment">// do some stuff ...</span>
        callback(<span class="literal">null</span>, <span class="string">'one'</span>);
    },
    <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        <span class="comment">// do some more stuff ...</span>
        callback(<span class="literal">null</span>, <span class="string">'two'</span>);
    },
],
<span class="comment">// optional callback</span>
<span class="function"><span class="keyword">function</span><span class="params">(err, results)</span>{</span>
    <span class="comment">// results is now equal to ['one', 'two']</span>
});


<span class="comment">// an example using an object instead of an array</span>
async.series({
    one: <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            callback(<span class="literal">null</span>, <span class="number">1</span>);
        }, <span class="number">200</span>);
    },
    two: <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            callback(<span class="literal">null</span>, <span class="number">2</span>);
        }, <span class="number">100</span>);
    },
},
<span class="function"><span class="keyword">function</span><span class="params">(err, results)</span> {</span>
    <span class="comment">// results is now equal to: {one: 1, two: 2}</span>
});
</code></pre><hr>
<p><a name="parallel" /></p>
<h3 id="parallel(tasks,_[callback])">parallel(tasks, [callback])</h3>
<p>Run an array of functions in parallel, without waiting until the previous<br>function has completed. If any of the functions pass an error to its<br>callback, the main callback is immediately called with the value of the error.<br>Once the tasks have completed, the results are passed to the final callback as an<br>array.</p>
<p>It is also possible to use an object instead of an array. Each property will be<br>run as a function and the results will be passed to the final callback as an object<br>instead of an array. This can be a more readable way of handling results from<br>async.parallel.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>tasks - An array or object containing functions to run, each function is passed a<br>callback it must call on completion.</li>
<li>callback(err, results) - An optional callback to run once all the functions<br>have completed. This function gets an array of all the arguments passed to<br>the callbacks used in the array.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code>async.parallel([
    <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            callback(<span class="literal">null</span>, <span class="string">'one'</span>);
        }, <span class="number">200</span>);
    },
    <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            callback(<span class="literal">null</span>, <span class="string">'two'</span>);
        }, <span class="number">100</span>);
    },
],
<span class="comment">// optional callback</span>
<span class="function"><span class="keyword">function</span><span class="params">(err, results)</span>{</span>
    <span class="comment">// the results array will equal ['one','two'] even though</span>
    <span class="comment">// the second function had a shorter timeout.</span>
});


<span class="comment">// an example using an object instead of an array</span>
async.parallel({
    one: <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            callback(<span class="literal">null</span>, <span class="number">1</span>);
        }, <span class="number">200</span>);
    },
    two: <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            callback(<span class="literal">null</span>, <span class="number">2</span>);
        }, <span class="number">100</span>);
    },
},
<span class="function"><span class="keyword">function</span><span class="params">(err, results)</span> {</span>
    <span class="comment">// results is now equals to: {one: 1, two: 2}</span>
});
</code></pre><hr>
<p><a name="whilst" /></p>
<h3 id="whilst(test,_fn,_callback)">whilst(test, fn, callback)</h3>
<p>Repeatedly call fn, while test returns true. Calls the callback when stopped,<br>or an error occurs.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>test() - synchronous truth test to perform before each execution of fn.</li>
<li>fn(callback) - A function to call each time the test passes. The function is<br>passed a callback which must be called once it has completed with an optional<br>error as the first argument.</li>
<li>callback(err) - A callback which is called after the test fails and repeated<br>execution of fn has stopped.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code><span class="keyword">var</span> count = <span class="number">0</span>;

async.whilst(
    <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="keyword">return</span> count &lt; <span class="number">5</span>; },
    <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> {</span>
        count++;
        setTimeout(callback, <span class="number">1000</span>);
    },
    <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
        <span class="comment">// 5 seconds have passed</span>
    }
);
</code></pre><hr>
<p><a name="until" /></p>
<h3 id="until(test,_fn,_callback)">until(test, fn, callback)</h3>
<p>Repeatedly call fn, until test returns true. Calls the callback when stopped,<br>or an error occurs.</p>
<p>The inverse of async.whilst.</p>
<hr>
<p><a name="waterfall" /></p>
<h3 id="waterfall(tasks,_[callback])">waterfall(tasks, [callback])</h3>
<p>Runs an array of functions in series, each passing their results to the next in<br>the array. However, if any of the functions pass an error to the callback, the<br>next function is not executed and the main callback is immediately called with<br>the error.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>tasks - An array of functions to run, each function is passed a callback it<br>must call on completion.</li>
<li>callback(err, [results]) - An optional callback to run once all the functions<br>have completed. This will be passed the results of the last task’s callback.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code>async.waterfall([
    <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        callback(<span class="literal">null</span>, <span class="string">'one'</span>, <span class="string">'two'</span>);
    },
    <span class="function"><span class="keyword">function</span><span class="params">(arg1, arg2, callback)</span>{</span>
        callback(<span class="literal">null</span>, <span class="string">'three'</span>);
    },
    <span class="function"><span class="keyword">function</span><span class="params">(arg1, callback)</span>{</span>
        <span class="comment">// arg1 now equals 'three'</span>
        callback(<span class="literal">null</span>, <span class="string">'done'</span>);
    }
], <span class="function"><span class="keyword">function</span> <span class="params">(err, result)</span> {</span>
   <span class="comment">// result now equals 'done'    </span>
});
</code></pre><hr>
<p><a name="queue" /></p>
<h3 id="queue(worker,_concurrency)">queue(worker, concurrency)</h3>
<p>Creates a queue object with the specified concurrency. Tasks added to the<br>queue will be processed in parallel (up to the concurrency limit). If all<br>workers are in progress, the task is queued until one is available. Once<br>a worker has completed a task, the task’s callback is called.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>worker(task, callback) - An asynchronous function for processing a queued<br>task.</li>
<li>concurrency - An integer for determining how many worker functions should be<br>run in parallel.</li>
</ul>
<p><strong>Queue objects</strong></p>
<p>The queue object returned by this function has the following properties and<br>methods:</p>
<ul>
<li>length() - a function returning the number of items waiting to be processed.</li>
<li>concurrency - an integer for determining how many worker functions should be<br>run in parallel. This property can be changed after a queue is created to<br>alter the concurrency on-the-fly.</li>
<li>push(task, [callback]) - add a new task to the queue, the callback is called<br>once the worker has finished processing the task.<br>instead of a single task, an array of tasks can be submitted. the respective callback is used for every task in the list.</li>
<li>saturated - a callback that is called when the queue length hits the concurrency and further tasks will be queued</li>
<li>empty - a callback that is called when the last item from the queue is given to a worker</li>
<li>drain - a callback that is called when the last item from the queue has returned from the worker</li>
</ul>
<p><strong>Example</strong></p>
<pre><code><span class="comment">// create a queue object with concurrency 2</span>

<span class="keyword">var</span> q = async.queue(<span class="function"><span class="keyword">function</span> <span class="params">(task, callback)</span> {</span>
    console.log(<span class="string">'hello '</span> + task.name);
    callback();
}, <span class="number">2</span>);


<span class="comment">// assign a callback</span>
q.drain = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(<span class="string">'all items have been processed'</span>);
}

<span class="comment">// add some items to the queue</span>

q.push({name: <span class="string">'foo'</span>}, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    console.log(<span class="string">'finished processing foo'</span>);
});
q.push({name: <span class="string">'bar'</span>}, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    console.log(<span class="string">'finished processing bar'</span>);
});

<span class="comment">// add some items to the queue (batch-wise)</span>

q.push([{name: <span class="string">'baz'</span>},{name: <span class="string">'bay'</span>},{name: <span class="string">'bax'</span>}], <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    console.log(<span class="string">'finished processing bar'</span>);
});
</code></pre><hr>
<p><a name="auto" /></p>
<h3 id="auto(tasks,_[callback])">auto(tasks, [callback])</h3>
<p>Determines the best order for running functions based on their requirements.<br>Each function can optionally depend on other functions being completed first,<br>and each function is run as soon as its requirements are satisfied. If any of<br>the functions pass an error to their callback, that function will not complete<br>(so any other functions depending on it will not run) and the main callback<br>will be called immediately with the error. Functions also receive an object<br>containing the results of functions which have completed so far.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>tasks - An object literal containing named functions or an array of<br>requirements, with the function itself the last item in the array. The key<br>used for each function or array is used when specifying requirements. The<br>syntax is easier to understand by looking at the example.</li>
<li>callback(err, results) - An optional callback which is called when all the<br>tasks have been completed. The callback will receive an error as an argument<br>if any tasks pass an error to their callback. If all tasks complete<br>successfully, it will receive an object containing their results.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code>async.auto({
    get_data: <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        <span class="comment">// async code to get some data</span>
    },
    make_folder: <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        <span class="comment">// async code to create a directory to store a file in</span>
        <span class="comment">// this is run at the same time as getting the data</span>
    },
    write_file: [<span class="string">'get_data'</span>, <span class="string">'make_folder'</span>, <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        <span class="comment">// once there is some data and the directory exists,</span>
        <span class="comment">// write the data to a file in the directory</span>
        callback(<span class="literal">null</span>, filename);
    }],
    email_link: [<span class="string">'write_file'</span>, <span class="function"><span class="keyword">function</span><span class="params">(callback, results)</span>{</span>
        <span class="comment">// once the file is written let's email a link to it...</span>
        <span class="comment">// results.write_file contains the filename returned by write_file.</span>
    }]
});
</code></pre><p>This is a fairly trivial example, but to do this using the basic parallel and<br>series functions would look like this:</p>
<pre><code>async.parallel([
    <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        <span class="comment">// async code to get some data</span>
    },
    <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        <span class="comment">// async code to create a directory to store a file in</span>
        <span class="comment">// this is run at the same time as getting the data</span>
    }
],
<span class="function"><span class="keyword">function</span><span class="params">(results)</span>{</span>
    async.series([
        <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
            <span class="comment">// once there is some data and the directory exists,</span>
            <span class="comment">// write the data to a file in the directory</span>
        },
        email_link: <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
            <span class="comment">// once the file is written let's email a link to it...</span>
        }
    ]);
});
</code></pre><p>For a complicated series of async tasks using the auto function makes adding<br>new tasks much easier and makes the code more readable.</p>
<hr>
<p><a name="iterator" /></p>
<h3 id="iterator(tasks)">iterator(tasks)</h3>
<p>Creates an iterator function which calls the next function in the array,<br>returning a continuation to call the next one after that. Its also possible to<br>‘peek’ the next iterator by doing iterator.next().</p>
<p>This function is used internally by the async module but can be useful when<br>you want to manually control the flow of functions in series.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>tasks - An array of functions to run, each function is passed a callback it<br>must call on completion.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code><span class="keyword">var</span> iterator = async.iterator([
    <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span> sys.p(<span class="string">'one'</span>); },
    <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span> sys.p(<span class="string">'two'</span>); },
    <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span> sys.p(<span class="string">'three'</span>); }
]);

node&gt; <span class="keyword">var</span> iterator2 = iterator();
<span class="string">'one'</span>
node&gt; <span class="keyword">var</span> iterator3 = iterator2();
<span class="string">'two'</span>
node&gt; iterator3();
<span class="string">'three'</span>
node&gt; <span class="keyword">var</span> nextfn = iterator2.next();
node&gt; nextfn();
<span class="string">'three'</span>
</code></pre><hr>
<p><a name="apply" /></p>
<h3 id="apply(function,_arguments-)">apply(function, arguments..)</h3>
<p>Creates a continuation function with some arguments already applied, a useful<br>shorthand when combined with other control flow functions. Any arguments<br>passed to the returned function are added to the arguments originally passed<br>to apply.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>function - The function you want to eventually apply all arguments to.</li>
<li>arguments… - Any number of arguments to automatically apply when the<br>continuation is called.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code><span class="comment">// using apply</span>

async.parallel([
    async.apply(fs.writeFile, <span class="string">'testfile1'</span>, <span class="string">'test1'</span>),
    async.apply(fs.writeFile, <span class="string">'testfile2'</span>, <span class="string">'test2'</span>),
]);


<span class="comment">// the same process without using apply</span>

async.parallel([
    <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        fs.writeFile(<span class="string">'testfile1'</span>, <span class="string">'test1'</span>, callback);
    },
    <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
        fs.writeFile(<span class="string">'testfile2'</span>, <span class="string">'test2'</span>, callback);
    },
]);
</code></pre><p>It’s possible to pass any number of additional arguments when calling the<br>continuation:</p>
<pre><code>node&gt; var <span class="function"><span class="keyword">fn</span> = <span class="title">async</span>.<span class="title">apply</span>(</span>sys.puts, <span class="string">'one'</span>);
node&gt; <span class="function"><span class="keyword">fn</span>(</span><span class="string">'two'</span>, <span class="string">'three'</span>);
one
two
three
</code></pre><hr>
<p><a name="nextTick" /></p>
<h3 id="nextTick(callback)">nextTick(callback)</h3>
<p>Calls the callback on a later loop around the event loop. In node.js this just<br>calls process.nextTick, in the browser it falls back to setTimeout(callback, 0),<br>which means other higher priority events may precede the execution of the callback.</p>
<p>This is used internally for browser-compatibility purposes.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>callback - The function to call on a later loop around the event loop.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code><span class="keyword">var</span> call_order = [];
async.nextTick(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    call_order.push(<span class="string">'two'</span>);
    <span class="comment">// call_order now equals ['one','two]</span>
});
call_order.push(<span class="string">'one'</span>)
</code></pre><h2 id="Utils-1">Utils</h2>
<p><a name="memoize" /></p>
<h3 id="memoize(fn,_[hasher])">memoize(fn, [hasher])</h3>
<p>Caches the results of an async function. When creating a hash to store function<br>results against, the callback is omitted from the hash and an optional hash<br>function can be used.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>fn - the function you to proxy and cache results from.</li>
<li>hasher - an optional function for generating a custom hash for storing<br>results, it has all the arguments applied to it apart from the callback, and<br>must be synchronous.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code><span class="keyword">var</span> slow_fn = <span class="function"><span class="keyword">function</span> <span class="params">(name, callback)</span> {</span>
    <span class="comment">// do something</span>
    callback(<span class="literal">null</span>, result);
};
<span class="keyword">var</span> fn = async.memoize(slow_fn);

<span class="comment">// fn can now be used as if it were slow_fn</span>
fn(<span class="string">'some name'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">// callback</span>
});
</code></pre><p><a name="unmemoize" /></p>
<h3 id="unmemoize(fn)">unmemoize(fn)</h3>
<p>Undoes a memoized function, reverting it to the original, unmemoized<br>form. Comes handy in tests.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>fn - the memoized function</li>
</ul>
<p><a name="log" /></p>
<h3 id="log(function,_arguments)">log(function, arguments)</h3>
<p>Logs the result of an async function to the console. Only works in node.js or<br>in browsers that support console.log and console.error (such as FF and Chrome).<br>If multiple arguments are returned from the async function, console.log is<br>called on each argument in order.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>function - The function you want to eventually apply all arguments to.</li>
<li>arguments… - Any number of arguments to apply to the function.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span><span class="params">(name, callback)</span>{</span>
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        callback(<span class="literal">null</span>, <span class="string">'hello '</span> + name);
    }, <span class="number">1000</span>);
};

node&gt; async.log(hello, <span class="string">'world'</span>);
<span class="string">'hello world'</span>
</code></pre><hr>
<p><a name="dir" /></p>
<h3 id="dir(function,_arguments)">dir(function, arguments)</h3>
<p>Logs the result of an async function to the console using console.dir to<br>display the properties of the resulting object. Only works in node.js or<br>in browsers that support console.dir and console.error (such as FF and Chrome).<br>If multiple arguments are returned from the async function, console.dir is<br>called on each argument in order.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>function - The function you want to eventually apply all arguments to.</li>
<li>arguments… - Any number of arguments to apply to the function.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span><span class="params">(name, callback)</span>{</span>
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        callback(<span class="literal">null</span>, {hello: name});
    }, <span class="number">1000</span>);
};

node&gt; async.dir(hello, <span class="string">'world'</span>);
{hello: <span class="string">'world'</span>}
</code></pre><hr>
<p><a name="noConflict" /></p>
<h3 id="noConflict()">noConflict()</h3>
<p>Changes the value of async back to its original value, returning a reference to the<br>async object.</p>
