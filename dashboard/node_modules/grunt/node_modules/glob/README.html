<h1 id="Glob">Glob</h1>
<p>This is a glob implementation in JavaScript.  It uses the <code>minimatch</code><br>library to do its matching.</p>
<h2 id="Attention:_node-glob_users!">Attention: node-glob users!</h2>
<p>The API has changed dramatically between 2.x and 3.x. This library is<br>now 100% JavaScript, and the integer flags have been replaced with an<br>options object.</p>
<p>Also, there’s an event emitter class, proper tests, and all the other<br>things you’ve come to expect from node modules.</p>
<p>And best of all, no compilation!</p>
<h2 id="Usage">Usage</h2>
<pre><code class="javascript"><span class="keyword">var</span> glob = <span class="built_in">require</span>(<span class="string">"glob"</span>)

<span class="comment">// options is optional</span>
glob(<span class="string">"**/*.js"</span>, options, <span class="function"><span class="keyword">function</span> <span class="params">(er, files)</span> {</span>
  <span class="comment">// files is an array of filenames.</span>
  <span class="comment">// If the `nonull` option is set, and nothing</span>
  <span class="comment">// was found, then files is ["**/*.js"]</span>
  <span class="comment">// er is an error object or null.</span>
})
</code></pre>
<h2 id="Features">Features</h2>
<p>Please see the <a href="https://github.com/isaacs/minimatch">minimatch<br>documentation</a> for more details.</p>
<p>Supports these glob features:</p>
<ul>
<li>Brace Expansion</li>
<li>Extended glob matching</li>
<li>“Globstar” <code>**</code> matching</li>
</ul>
<p>See:</p>
<ul>
<li><code>man sh</code></li>
<li><code>man bash</code></li>
<li><code>man 3 fnmatch</code></li>
<li><code>man 5 gitignore</code></li>
<li><a href="https://github.com/isaacs/minimatch">minimatch documentation</a></li>
</ul>
<h2 id="glob(pattern,_[options],_cb)">glob(pattern, [options], cb)</h2>
<ul>
<li><code>pattern</code> {String} Pattern to be matched</li>
<li><code>options</code> {Object}</li>
<li><code>cb</code> {Function}<ul>
<li><code>err</code> {Error | null}</li>
<li><code>matches</code> {Array<String>} filenames found matching the pattern</li>
</ul>
</li>
</ul>
<p>Perform an asynchronous glob search.</p>
<h2 id="glob-sync(pattern,_[options]">glob.sync(pattern, [options]</h2>
<ul>
<li><code>pattern</code> {String} Pattern to be matched</li>
<li><code>options</code> {Object}</li>
<li>return: {Array<String>} filenames found matching the pattern</li>
</ul>
<p>Perform a synchronous glob search.</p>
<h2 id="Class:_glob-Glob">Class: glob.Glob</h2>
<p>Create a Glob object by instanting the <code>glob.Glob</code> class.</p>
<pre><code class="javascript"><span class="keyword">var</span> Glob = <span class="built_in">require</span>(<span class="string">"glob"</span>).Glob
<span class="keyword">var</span> mg = <span class="keyword">new</span> Glob(pattern, options, cb)
</code></pre>
<p>It’s an EventEmitter, and starts walking the filesystem to find matches<br>immediately.</p>
<h3 id="new_glob-Glob(pattern,_[options],_[cb])">new glob.Glob(pattern, [options], [cb])</h3>
<ul>
<li><code>pattern</code> {String} pattern to search for</li>
<li><code>options</code> {Object}</li>
<li><code>cb</code> {Function} Called when an error occurs, or matches are found<ul>
<li><code>err</code> {Error | null}</li>
<li><code>matches</code> {Array<String>} filenames found matching the pattern</li>
</ul>
</li>
</ul>
<p>Note that if the <code>sync</code> flag is set in the options, then matches will<br>be immediately available on the <code>g.found</code> member.</p>
<h3 id="Properties">Properties</h3>
<ul>
<li><code>minimatch</code> The minimatch object that the glob uses.</li>
<li><code>options</code> The options object passed in.</li>
<li><code>error</code> The error encountered.  When an error is encountered, the<br>glob object is in an undefined state, and should be discarded.</li>
<li><code>aborted</code> Boolean which is set to true when calling <code>abort()</code>.  There<br>is no way at this time to continue a glob search after aborting, but<br>you can re-use the statCache to avoid having to duplicate syscalls.</li>
</ul>
<h3 id="Events">Events</h3>
<ul>
<li><code>end</code> When the matching is finished, this is emitted with all the<br>matches found.  If the <code>nonull</code> option is set, and no match was found,<br>then the <code>matches</code> list contains the original pattern.  The matches<br>are sorted, unless the <code>nosort</code> flag is set.</li>
<li><code>match</code> Every time a match is found, this is emitted with the matched.</li>
<li><code>error</code> Emitted when an unexpected error is encountered, or whenever<br>any fs error occurs if <code>options.strict</code> is set.</li>
<li><code>abort</code> When <code>abort()</code> is called, this event is raised.</li>
</ul>
<h3 id="Methods">Methods</h3>
<ul>
<li><code>abort</code> Stop the search.</li>
</ul>
<h3 id="Options">Options</h3>
<p>All the options that can be passed to Minimatch can also be passed to<br>Glob to change pattern matching behavior.  Also, some have been added,<br>or have glob-specific ramifications.</p>
<p>All options are false by default, unless otherwise noted.</p>
<p>All options are added to the glob object, as well.</p>
<ul>
<li><code>cwd</code> The current working directory in which to search.  Defaults<br>to <code>process.cwd()</code>.</li>
<li><code>root</code> The place where patterns starting with <code>/</code> will be mounted<br>onto.  Defaults to <code>path.resolve(options.cwd, &quot;/&quot;)</code> (<code>/</code> on Unix<br>systems, and <code>C:\</code> or some such on Windows.)</li>
<li><code>nomount</code> By default, a pattern starting with a forward-slash will be<br>“mounted” onto the root setting, so that a valid filesystem path is<br>returned.  Set this flag to disable that behavior.</li>
<li><code>mark</code> Add a <code>/</code> character to directory matches.  Note that this<br>requires additional stat calls.</li>
<li><code>nosort</code> Don’t sort the results.</li>
<li><code>stat</code> Set to true to stat <em>all</em> results.  This reduces performance<br>somewhat, and is completely unnecessary, unless <code>readdir</code> is presumed<br>to be an untrustworthy indicator of file existence.  It will cause<br>ELOOP to be triggered one level sooner in the case of cyclical<br>symbolic links.</li>
<li><code>silent</code> When an unusual error is encountered<br>when attempting to read a directory, a warning will be printed to<br>stderr.  Set the <code>silent</code> option to true to suppress these warnings.</li>
<li><code>strict</code> When an unusual error is encountered<br>when attempting to read a directory, the process will just continue on<br>in search of other matches.  Set the <code>strict</code> option to raise an error<br>in these cases.</li>
<li><code>statCache</code> A cache of results of filesystem information, to prevent<br>unnecessary stat calls.  While it should not normally be necessary to<br>set this, you may pass the statCache from one glob() call to the<br>options object of another, if you know that the filesystem will not<br>change between calls.  (See “Race Conditions” below.)</li>
<li><code>sync</code> Perform a synchronous glob search.</li>
<li><code>nounique</code> In some cases, brace-expanded patterns can result in the<br>same file showing up multiple times in the result set.  By default,<br>this implementation prevents duplicates in the result set.<br>Set this flag to disable that behavior.</li>
<li><code>nonull</code> Set to never return an empty set, instead returning a set<br>containing the pattern itself.  This is the default in glob(3).</li>
<li><code>nocase</code> Perform a case-insensitive match.  Note that case-insensitive<br>filesystems will sometimes result in glob returning results that are<br>case-insensitively matched anyway, since readdir and stat will not<br>raise an error.</li>
<li><code>debug</code> Set to enable debug logging in minimatch and glob.</li>
<li><code>globDebug</code> Set to enable debug logging in glob, but not minimatch.</li>
</ul>
<h2 id="Comparisons_to_other_fnmatch/glob_implementations">Comparisons to other fnmatch/glob implementations</h2>
<p>While strict compliance with the existing standards is a worthwhile<br>goal, some discrepancies exist between node-glob and other<br>implementations, and are intentional.</p>
<p>If the pattern starts with a <code>!</code> character, then it is negated.  Set the<br><code>nonegate</code> flag to suppress this behavior, and treat leading <code>!</code><br>characters normally.  This is perhaps relevant if you wish to start the<br>pattern with a negative extglob pattern like <code>!(a|B)</code>.  Multiple <code>!</code><br>characters at the start of a pattern will negate the pattern multiple<br>times.</p>
<p>If a pattern starts with <code>#</code>, then it is treated as a comment, and<br>will not match anything.  Use <code>\#</code> to match a literal <code>#</code> at the<br>start of a line, or set the <code>nocomment</code> flag to suppress this behavior.</p>
<p>The double-star character <code>**</code> is supported by default, unless the<br><code>noglobstar</code> flag is set.  This is supported in the manner of bsdglob<br>and bash 4.1, where <code>**</code> only has special significance if it is the only<br>thing in a path part.  That is, <code>a/**/b</code> will match <code>a/x/y/b</code>, but<br><code>a/**b</code> will not.  <strong>Note that this is different from the way that `</strong><code>is
handled by ruby&#39;s</code>Dir` class.**</p>
<p>If an escaped pattern has no matches, and the <code>nonull</code> flag is set,<br>then glob returns the pattern as-provided, rather than<br>interpreting the character escapes.  For example,<br><code>glob.match([], &quot;\\*a\\?&quot;)</code> will return <code>&quot;\\*a\\?&quot;</code> rather than<br><code>&quot;*a?&quot;</code>.  This is akin to setting the <code>nullglob</code> option in bash, except<br>that it does not resolve escaped pattern characters.</p>
<p>If brace expansion is not disabled, then it is performed before any<br>other interpretation of the glob pattern.  Thus, a pattern like<br><code>+(a|{b),c)}</code>, which would not be valid in bash or zsh, is expanded<br><strong>first</strong> into the set of <code>+(a|b)</code> and <code>+(a|c)</code>, and those patterns are<br>checked for validity.  Since those two are valid, matching proceeds.</p>
<h2 id="Windows">Windows</h2>
<p><strong>Please only use forward-slashes in glob expressions.</strong></p>
<p>Though windows uses either <code>/</code> or <code>\</code> as its path separator, only <code>/</code><br>characters are used by this glob implementation.  You must use<br>forward-slashes <strong>only</strong> in glob expressions.  Back-slashes will always<br>be interpreted as escape characters, not path separators.</p>
<p>Results from absolute patterns such as <code>/foo/*</code> are mounted onto the<br>root setting using <code>path.join</code>.  On windows, this will by default result<br>in <code>/foo/*</code> matching <code>C:\foo\bar.txt</code>.</p>
<h2 id="Race_Conditions">Race Conditions</h2>
<p>Glob searching, by its very nature, is susceptible to race conditions,<br>since it relies on directory walking and such.</p>
<p>As a result, it is possible that a file that exists when glob looks for<br>it may have been deleted or modified by the time it returns the result.</p>
<p>As part of its internal implementation, this program caches all stat<br>and readdir calls that it makes, in order to cut down on system<br>overhead.  However, this also makes it even more susceptible to races,<br>especially if the statCache object is reused between glob calls.</p>
<p>Users are thus advised not to use a glob result as a<br>guarantee of filesystem state in the face of rapid changes.<br>For the vast majority of operations, this is never a problem.</p>
